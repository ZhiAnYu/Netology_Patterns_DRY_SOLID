# Задача Магазин

## Описание
Это финальная задача! В этом задании попрактикуемся с правилами чистого кода и принципами SOLID.

Нужно написать программу-магазин, в которой пользователи заказывают товары. Вам предоставляется свобода в продумывании функциональности вашей программы, как и в проектировании её структуры. В процессе реализации вы должны применить принцип избегания магических чисел, DRY и как минимум 4 из 5 принципов SOLID, при отправке решения в комментарии к работе указать по одному примеру применения каждого принципа в вашем решении со ссылками на конкретные места кода на гитхабе и обоснованием в чём заключалось применение принципа.

Примеры возможностей программы:
* Вывод доступных для покупки товаров (+)
* Фильтрация товаров по ключевым словам, ценам, производителям (-) 
* Составление продуктовой корзины пользователя (+)
* Трекинг заказа в системе доставки (+)
* Возврат заказа, повтороение заказа (+/-) Добавлено - не реализовано
* Система рейтинга для товаров (+) 
* Простая рекомендательная система для покупок (+)      можно поменять 1. Самый выбираемый товар/2. Самый НЕвыбираемый товар/ 3. Рандомный товар

## Реализация
## 1. Избегание магических чисел: 

Вместо конкретных чисел, которые обозначают различные товары (в примере это 4 вида) используем длину массива, в который и вносим сами товары. Тогда при добавлении новых товаров все корректно поменяется

```java
public static int[] inputCount = new int[PRODUCTS.length];
public static int[] currentPrices = new int[PRICES.length];
```
## 2. DRY: Вместо постоянного повтора кода для вывода на консоль списка товара для покупки использование метода showMenu(), вместо повтора кода рекомендаций использование метода advertising()
   
```java
    System.out.println("В нашем магазине есть: ");
        for (int i = 0; i < Basket.PRODUCTS.length; i++) {
            System.out.println((i + 1) + " "
                    + Basket.PRODUCTS[i].getNameItem() + " "
                    + Basket.PRICES[i] + " руб/ед");
        }
```

```java
public static void advertising() {
        int[] popItem = new int[PRODUCTS.length];
        int maxIndex = 0;
        for (int i = 0; i < PRODUCTS.length; i++) {
            popItem[i] = PRODUCTS[i].getRatingItem();
            if (popItem[i] > popItem[maxIndex]) {
                maxIndex = i;
            }
        }
        System.out.println("Наш самый популярный товар на сегодня: " + PRODUCTS[maxIndex].getNameItem());
    }
```

```java
Basket.showMenu();
Basket.advertising();
```

## 3. SOLID:
*S - принцип единственной ответственности (Single Responsibility Principle)
Класс должен выполнять только те функции, для которых он логически предназначен.*

* Класс Basket - предназначен для описания корзины. Для улучшения кода можно вынести список имеющихся товаров в отдельный JSON файл , с последующим парсингом в объект Basket.
* класс User предназначен для описания покупателя с уникальным ID и адресом для отправки заказа.
* класс Item предназначен для описания каждого отдельного товара с полями наименования, класса товара (в примере - Meal=еда, для расширение ассортимента магазина классами Одежда, Косметика и пр. ).
* интерфейс Payment предназначен для оплаты, причем реализация метода будет разной для каждого класса. PaymentCard - предназначен для оплаты картами. Возможно добалвение классов PaymentPaypal, PaymentBitcoin и пр. 

*O - принцип открытости/закрытости (Open Closed Principle)
Программные сущности должны быть открыты для расширения, но закрыты для модификации.*

Класс Item  можно сделать абстрактным и расширить классами Meal, Clothes, Beauty тогда можно добавлять разные поля вроде "Срока годности", "Веса" и прочих не меняя основной класс Item

*L - принцип замены Барбары Лисков (Liskov Substitution Principle)
Наследуй только тогда, когда можешь играть роль за предка.*

Возможно речь о том, что не стоит наследовать Order от Basket? 
Оба класса имеют дело с товарами, но предназначены для разных сюжетов.  

*I - принцип сегрегации (разделения) интерфейса (Interface Segregation Principle)
Много интерфейсов, специально предназначенных для клиентов, лучше, чем один
интерфейс общего назначения.*

В примере кода можно выделить метод cancelOrder  в отдельный интерфейс Cancelable (с описанием системы возврата денежных средств), так как например для товаров класса Лекарства возврат товара невозможен. В этом случае можно сделать класс-наследник OrderMedicine только для инетрфейса Order. Для других же классов (Еда, Одежда, Косметика) сделать множественное наследование обоих интерфейсов Order и Cancelable 

```java
public interface Order {
    void sendOrder(User user, List<String> userBasket);

    void repeatOrder(List <String> userBasket);  

    void cancelOrder(List <String> userBasket);
}
```


*D - принцип инверсии зависимостей (Dependency Inversion Principle)* 

Тип оплаты не будет влиять на программу. Главное, чтобы проверка на isPay вернула true

```java
Payment paymentCard = new PaymentCard();
paymentCard.pay(); 
Order userOrder = new OrderImpl();
userOrder.sendOrder(user1,userBasket);
..
public class PaymentCard implements Payment{
    static boolean isPay;
    @Override
    public void pay(){
        System.out.println("Оплата прошла");
        isPay = true;
    }
}

```

